{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to The Replica Project's Documentation If you are interested to look into the project it can be found here . From here on it will be technical details about the project. Prerequisite Knowledge Required We assume that anyone who is reading this documentation has knowledge on the following technologies. Javascript PHP HTML Bootstrap 4 D3.js Leaflet.js Jquery Highcharts Datatables 4 CSV Data CSS Async (A asynchronous utility in javascript) JSON If you don't have prior knowledge, we would recommend reading the documentation of the technolgies as we use them heavily. Some optional tools/technolgies to look at. Mkdocs (With this tool we created the documentation) Python Git Diffchecker (Productivity) Docx to HTML conversion (Some static textual content generation) PHPStorm/WebStorm (Student account from Jet Brains) Architecture As you can see from the figure that our architecture is very simple. So if currently someone just wants to use our code, they can just use their excel sheets and host it on their website. For now, we are not using a database as our data is not that big. But this can be very easily added in future once our data is suffcient enough. Directory Structure The directory structure of the code is as follows:- docs: This is a directory which contains all the software documentation for this project. lib: This contains some javascript libraries which are common to both version 1 and 2. It will have rangeslider which is used in transactional network and leaflet library used for displaying maps. public: Most of the static content in this file is used by version 1. There is one directory data which is used by all the php scripts. If you want to add more spreadsheets or if you want to clone this repo and update with your data then you will need to manipulate this directory. v2: This is the directory where all the static files for version 2 are kept. It will have it's separate public directory having css and js directories. Adding more spreadsheets to the system. If you are looking to add more spreadsheets to the current system, follow the below steps. Go to the <project folder>/public/data . There you will see all the painting names. Create a directory with the new painting name. In that put the CSV in the same format as in other paintings. Please verify that the CSV format is similar to the one in other files. Once it is done, inside the same directory create another directory called Replicas . For each individual replica, create a separate directory. In every directory of the individual replica put the image with name image.jpg . Also create another directory inside the replica directory with name Owners . In the owners directory create directory with name of the Owner and inside that put the image of the owner and bio of the owner with names About.txt and image.jpg . Once you do that the data will automatically populate on the system. Make sure you ask an update on histogram visuals. Those visuals are static and would require some updated information for Professor Codell. Make the website for different painter. Just clone the entire project and manipulate the data directory as described above. In all the javascript files change the name from herberger to the new name given to the clone project and the project will be ready. PS: If you do that, you could also create a configuration file which can do that automatically. If the project is expanding then it would make sense to do that. Populate the content of histogram visuals accordingly as those are generated using static data. Code Structure There are two parts to the code. Backend Frontend","title":"Welcome"},{"location":"#welcome-to-the-replica-projects-documentation","text":"If you are interested to look into the project it can be found here . From here on it will be technical details about the project.","title":"Welcome to The Replica Project's Documentation"},{"location":"#prerequisite-knowledge-required","text":"We assume that anyone who is reading this documentation has knowledge on the following technologies. Javascript PHP HTML Bootstrap 4 D3.js Leaflet.js Jquery Highcharts Datatables 4 CSV Data CSS Async (A asynchronous utility in javascript) JSON If you don't have prior knowledge, we would recommend reading the documentation of the technolgies as we use them heavily. Some optional tools/technolgies to look at. Mkdocs (With this tool we created the documentation) Python Git Diffchecker (Productivity) Docx to HTML conversion (Some static textual content generation) PHPStorm/WebStorm (Student account from Jet Brains)","title":"Prerequisite Knowledge Required"},{"location":"#architecture","text":"As you can see from the figure that our architecture is very simple. So if currently someone just wants to use our code, they can just use their excel sheets and host it on their website. For now, we are not using a database as our data is not that big. But this can be very easily added in future once our data is suffcient enough.","title":"Architecture"},{"location":"#directory-structure","text":"The directory structure of the code is as follows:- docs: This is a directory which contains all the software documentation for this project. lib: This contains some javascript libraries which are common to both version 1 and 2. It will have rangeslider which is used in transactional network and leaflet library used for displaying maps. public: Most of the static content in this file is used by version 1. There is one directory data which is used by all the php scripts. If you want to add more spreadsheets or if you want to clone this repo and update with your data then you will need to manipulate this directory. v2: This is the directory where all the static files for version 2 are kept. It will have it's separate public directory having css and js directories.","title":"Directory Structure"},{"location":"#adding-more-spreadsheets-to-the-system","text":"If you are looking to add more spreadsheets to the current system, follow the below steps. Go to the <project folder>/public/data . There you will see all the painting names. Create a directory with the new painting name. In that put the CSV in the same format as in other paintings. Please verify that the CSV format is similar to the one in other files. Once it is done, inside the same directory create another directory called Replicas . For each individual replica, create a separate directory. In every directory of the individual replica put the image with name image.jpg . Also create another directory inside the replica directory with name Owners . In the owners directory create directory with name of the Owner and inside that put the image of the owner and bio of the owner with names About.txt and image.jpg . Once you do that the data will automatically populate on the system. Make sure you ask an update on histogram visuals. Those visuals are static and would require some updated information for Professor Codell.","title":"Adding more spreadsheets to the system."},{"location":"#make-the-website-for-different-painter","text":"Just clone the entire project and manipulate the data directory as described above. In all the javascript files change the name from herberger to the new name given to the clone project and the project will be ready. PS: If you do that, you could also create a configuration file which can do that automatically. If the project is expanding then it would make sense to do that. Populate the content of histogram visuals accordingly as those are generated using static data.","title":"Make the website for different painter."},{"location":"#code-structure","text":"There are two parts to the code. Backend Frontend","title":"Code Structure"},{"location":"Backend/","text":"Backend In this section all the REST PHP files will be explained. We assume prior knowledge of PHP here on. allSocialNetwork.php This API helps in getting the Transactional Network for all the paintings. Requires commons.php Params: Get start: year from which the network should be created end: year till which the network should be created Algorithm: This file starts with looping over every painting name in <code>/public/data and reading the data.csv file which currently acts like a database for the painting. This file contains information of Replica being transferred to many different owners. First a variable $dataCreation is intitilized which has a key element . The purpose of this is to store the previous elements which have been read. This helps in tracking the parent node from whom the painting was transfered. The algorithm for every row works in this fashion:- If the node has a parent node create a transactions information with source and target and if not then do nothing. Updates the In-Nodes(Buying Paintings) and Out-Nodes(Selling Paintings). In-Nodes for the person who is taking the painting and out-node for person who is giving the painting. Insert the element in $dataCreation The whole algorithm depends of HashMap and names being unique. If the names are not unique then alterations to algorithms would be required. commons.php This Library is used by all REST scripts. Basically this provides function to output data in json format. getComparisonNetwork.php Requires commons.php Params: Get name: Name of the Painting Algorithm: This REST script is very easy to understand. It takes the the name of the painting and reads the data.csv of that painting. For every row it inserts a record in the output array which has [Replica ID, [Array of information required]] . If you would have to change anything it will probably in [Array of information Required] . Please don't change the order, if you want to add more content just append to that array. getPaintingImages.php Requires commons.php Params: Get name: Name of the Painting Algorithm: The algorithms is very similar to getComparisonNetwork.php . The difference lies in that it pushes the image link to be used in img tag. If you plan to upgrade the website we would recommend merging the two scripts. getPaintings.php Requires commons.php Params: Get name: Name of the Painting Algorithm: This just returns the scandir result of <code>/public/data directory. getRawData.php Requires commons.php Params: Get name: Name of the Painting Algorithm: This just reads every data.csv file and creates a entry for all the rows. You can maninpulate the data you would like to show in raw data visualisation. It will also add image information to the row which is nothing but just adding a link. getReplicaInfo.php Requires commons.php Params: Get paintingName: Name of the painting for which you want the data. paintingReplica: Replica for which you want the information. Algorithm: The purpose of this file is to provide the data for narrative visualisation. First this API will look into the paintingName directory, find the data.csv file and collect all the information about the paintingReplica . PS all this information about paintingReplica and paintingName can be taken from getReplicaName.php and getPaintings.php Once that is done the code tries to optimally store the content for frontend. Next thing is collection of owner information which includes about the owner narrative and image of the owner. This information is kept with every replica in data directory. Finally all data is passed to the api requester. getReplicaNames.php Requires commons.php Params: Get name: Name of the painting for which you want the data. Algorithm: This API provides all the names of Replica for a painting that it takes as a paramter. The results are from scandir function. getSocialNetworkData.php Requires commons.php Params: Get name: Name of the painting for which you want the data. Algorithm: This is same as allSocialNetwork.php . The only difference lies is in that it provides social network for a specific painting that it takes as a paramters. chord_diagram.php Requires commons.php Algorithm: This file is used to collect information on chord flow. How this works is it scans all the excel CSVs in the data folder capture the replica flow and based on the year in which the transaction happened calculates the range of the year. Once the year range is defined the transaction is inserted in that range. In this key 1860 would represent that the transaction happened in between 1860-1885.","title":"Back End"},{"location":"Backend/#backend","text":"In this section all the REST PHP files will be explained. We assume prior knowledge of PHP here on.","title":"Backend"},{"location":"Backend/#allsocialnetworkphp","text":"This API helps in getting the Transactional Network for all the paintings. Requires commons.php Params: Get start: year from which the network should be created end: year till which the network should be created Algorithm: This file starts with looping over every painting name in <code>/public/data and reading the data.csv file which currently acts like a database for the painting. This file contains information of Replica being transferred to many different owners. First a variable $dataCreation is intitilized which has a key element . The purpose of this is to store the previous elements which have been read. This helps in tracking the parent node from whom the painting was transfered. The algorithm for every row works in this fashion:- If the node has a parent node create a transactions information with source and target and if not then do nothing. Updates the In-Nodes(Buying Paintings) and Out-Nodes(Selling Paintings). In-Nodes for the person who is taking the painting and out-node for person who is giving the painting. Insert the element in $dataCreation The whole algorithm depends of HashMap and names being unique. If the names are not unique then alterations to algorithms would be required.","title":"allSocialNetwork.php"},{"location":"Backend/#commonsphp","text":"This Library is used by all REST scripts. Basically this provides function to output data in json format.","title":"commons.php"},{"location":"Backend/#getcomparisonnetworkphp","text":"Requires commons.php Params: Get name: Name of the Painting Algorithm: This REST script is very easy to understand. It takes the the name of the painting and reads the data.csv of that painting. For every row it inserts a record in the output array which has [Replica ID, [Array of information required]] . If you would have to change anything it will probably in [Array of information Required] . Please don't change the order, if you want to add more content just append to that array.","title":"getComparisonNetwork.php"},{"location":"Backend/#getpaintingimagesphp","text":"Requires commons.php Params: Get name: Name of the Painting Algorithm: The algorithms is very similar to getComparisonNetwork.php . The difference lies in that it pushes the image link to be used in img tag. If you plan to upgrade the website we would recommend merging the two scripts.","title":"getPaintingImages.php"},{"location":"Backend/#getpaintingsphp","text":"Requires commons.php Params: Get name: Name of the Painting Algorithm: This just returns the scandir result of <code>/public/data directory.","title":"getPaintings.php"},{"location":"Backend/#getrawdataphp","text":"Requires commons.php Params: Get name: Name of the Painting Algorithm: This just reads every data.csv file and creates a entry for all the rows. You can maninpulate the data you would like to show in raw data visualisation. It will also add image information to the row which is nothing but just adding a link.","title":"getRawData.php"},{"location":"Backend/#getreplicainfophp","text":"Requires commons.php Params: Get paintingName: Name of the painting for which you want the data. paintingReplica: Replica for which you want the information. Algorithm: The purpose of this file is to provide the data for narrative visualisation. First this API will look into the paintingName directory, find the data.csv file and collect all the information about the paintingReplica . PS all this information about paintingReplica and paintingName can be taken from getReplicaName.php and getPaintings.php Once that is done the code tries to optimally store the content for frontend. Next thing is collection of owner information which includes about the owner narrative and image of the owner. This information is kept with every replica in data directory. Finally all data is passed to the api requester.","title":"getReplicaInfo.php"},{"location":"Backend/#getreplicanamesphp","text":"Requires commons.php Params: Get name: Name of the painting for which you want the data. Algorithm: This API provides all the names of Replica for a painting that it takes as a paramter. The results are from scandir function.","title":"getReplicaNames.php"},{"location":"Backend/#getsocialnetworkdataphp","text":"Requires commons.php Params: Get name: Name of the painting for which you want the data. Algorithm: This is same as allSocialNetwork.php . The only difference lies is in that it provides social network for a specific painting that it takes as a paramters.","title":"getSocialNetworkData.php"},{"location":"Backend/#chord_diagramphp","text":"Requires commons.php Algorithm: This file is used to collect information on chord flow. How this works is it scans all the excel CSVs in the data folder capture the replica flow and based on the year in which the transaction happened calculates the range of the year. Once the year range is defined the transaction is inserted in that range. In this key 1860 would represent that the transaction happened in between 1860-1885.","title":"chord_diagram.php"},{"location":"CodeIndex/","text":"Technical Documentation Hello and welcome to the Technical Documenation of the Replica Project. This documentation requires knowledge of PHP and Javascript so expertise in the language is assumed hereafter.","title":"Technical Documentation"},{"location":"CodeIndex/#technical-documentation","text":"Hello and welcome to the Technical Documenation of the Replica Project. This documentation requires knowledge of PHP and Javascript so expertise in the language is assumed hereafter.","title":"Technical Documentation"},{"location":"DirectoryStructure/","text":"Directory Structure The directory structure of the code is as follows:- docs: This is a directory which contains all the software documentation for this project. lib: This contains some javascript libraries which are common to both version 1 and 2. It will have rangeslider which is used in transactional network and leaflet library used for displaying maps. public: Most of the static content in this file is used by version 1. There is one directory data which is used by all the php scripts. If you want to add more spreadsheets or if you want to clone this repo and update with your data then you will need to manipulate this directory. v2: This is the directory where all the static files for version 2 are kept. It will have it's separate public directory having css and js directories. Adding more spreadsheets to the system. If you are looking to add more spreadsheets to the current system, follow the below steps. Go to the <project folder>/public/data . There you will see all the painting names. Create a directory with the new painting name. In that put the CSV in the same format as in other paintings. Please verify that the CSV format is similar to the one in other files. Once it is done, inside the same directory create another directory called Replicas . For each individual replica, create a separate directory. In every directory of the individual replica put the image with name image.jpg . Also create another directory inside the replica directory with name Owners . In the owners directory create directory with name of the Owner and inside that put the image of the owner and bio of the owner with names About.txt and image.jpg . Once you do that the data will automatically populate on the system. Make sure you ask an update on histogram visuals. Those visuals are static and would require some updated information for Professor Codell. Make the website for different painter. Just clone the entire project and manipulate the data directory as described above. In all the javascript files change the name from herberger to the new name given to the clone project and the project will be ready. PS: If you do that, you could also create a configuration file which can do that automatically. If the project is expanding then it would make sense to do that. Populate the content of histogram visuals accordingly as those are generated using static data.","title":"DirectoryStructure"},{"location":"DirectoryStructure/#directory-structure","text":"The directory structure of the code is as follows:- docs: This is a directory which contains all the software documentation for this project. lib: This contains some javascript libraries which are common to both version 1 and 2. It will have rangeslider which is used in transactional network and leaflet library used for displaying maps. public: Most of the static content in this file is used by version 1. There is one directory data which is used by all the php scripts. If you want to add more spreadsheets or if you want to clone this repo and update with your data then you will need to manipulate this directory. v2: This is the directory where all the static files for version 2 are kept. It will have it's separate public directory having css and js directories.","title":"Directory Structure"},{"location":"DirectoryStructure/#adding-more-spreadsheets-to-the-system","text":"If you are looking to add more spreadsheets to the current system, follow the below steps. Go to the <project folder>/public/data . There you will see all the painting names. Create a directory with the new painting name. In that put the CSV in the same format as in other paintings. Please verify that the CSV format is similar to the one in other files. Once it is done, inside the same directory create another directory called Replicas . For each individual replica, create a separate directory. In every directory of the individual replica put the image with name image.jpg . Also create another directory inside the replica directory with name Owners . In the owners directory create directory with name of the Owner and inside that put the image of the owner and bio of the owner with names About.txt and image.jpg . Once you do that the data will automatically populate on the system. Make sure you ask an update on histogram visuals. Those visuals are static and would require some updated information for Professor Codell.","title":"Adding more spreadsheets to the system."},{"location":"DirectoryStructure/#make-the-website-for-different-painter","text":"Just clone the entire project and manipulate the data directory as described above. In all the javascript files change the name from herberger to the new name given to the clone project and the project will be ready. PS: If you do that, you could also create a configuration file which can do that automatically. If the project is expanding then it would make sense to do that. Populate the content of histogram visuals accordingly as those are generated using static data.","title":"Make the website for different painter."},{"location":"Docs Generation/","text":"","title":"Docs Generation"},{"location":"Frontend/","text":"Version 2 - Front End In this knowledge of HTML, CSS3 and Javascript knowledge is assumed. The template we used for the version can be found here . Most of the styling stuff is used from Bootstrap 4. If you are interested in styling changes visit v2/index.html and change accordingly with bootstrap. File : v2/public/css/index.css This file contains CSS 3 code for some of the utilities we used in developing visualisation. In the code we mentioned in the comments that for what widget/visualisation the styling is done. You can reference that. Here it is assumed that the developer knows CSS. File : v2/public/js/chord_diagram.js This file is imported in index.html and the code in this file is responsible for populating the data for chord visuals. Algorithm: It makes a hit on REST API: /herberger/chordDiagram.php to collect the data using Jquery get request. The data is expected in following format { \"type\" : \"Success\", \"message\" : \"Data found\", \"data\": { \"matrix\": { \"<year>\":{ \"<Seller Name>\" : { \"<Buyer Name>\": <How Many Paintings> } } } } } The data returned has a dictionary with keys as year numbers. We run a loop on the dictionary key to build each and every chord diagram. To build the chord diagram for every year range build_chord will run and it takes 3 parameters matrix(adjacency matrix for the graph), names(owners who were involved in the transactions) and id which will be used to fetch the specific svg for this chord. How an individual chord is created is a follows: First the names are sorted on the basis of type of profession they are in. So dealers will have priority 1, museums will have priority 2 and individuals will have priority 3. Then we create a adjaceny matrix array as D3 requires that. Once that is done we have all the ingridients for the creating the d3 chord. If you don't know how to use D3 chord diagram follow this tutorial . To provide with the on hover lighting effect what we have done is we have set the opacity of the ribbons in the D3 chord with opacity 0.7. Once you hover over a ribbon the opacity is set to 1 which makes the ribbon prominent. Once you hover out the opacity is again set to 0.7. It has built with traditional d3 visualisation so please follow the tutorial mentioned if you don't understand how to make d3 chord charts. File : v2/public/js/comparisonTab.js This file is also imported by index.html and the code in the file populates the Trajectory Comparison maps. The data is expected in the following format. { \"type\" : \"Success\", \"message\" : \"Data found\", \"data\": { \"<Replica Id>\": JSONArray([(Latitude), (Longitude), (Year), (Painting Type), (Size), (City)......]) } } Algorithm: Whenever a user clicks on the left panel option Trajectory Comparison after 1 second the update is called. Why there is a delay because Leaflet, the library used for map visuals won't work properly if the maps are not visible and it takes time for browser to render things. So to compensate for that we put a delay. Now how maps are populated is first /herberger/getComparisonNetwork.php?name=<painting name> is called using ajax get of jquery. Painting name is automatically picked from the dropdown and the content in the dropdown is populated in v2/public/js/index/js . The data collected is in form of key value pair where key is the replica id for the painting value is information array of different geographical information. This is sufficient to populate the data for Leaflet. So based on number of replicas tiles are created and are populated with maps and trajectories. PS: onchange listener is active on the dropdown. This code will be available in this file. So if you change the dropdown the content updates. The id for the dropdown is #comparisonPaintingPicker . File : v2/public/js/histograms.js This file is also imported by index.html and the code in the fie populates the content for Histogram Visuals. Algorithm: A little knowledge on Highcharts.js is assumed here. If you don't know, you don't need to learn entire thing. Just read the options of this visualisation. In the visualisation mentioned we have changed just the data and remaining things are same so it should be pretty starightford to build something in this domain. If you add more excel sheets or plan to add more artists, you will need to update the content in the options of the Highcharts.js. It should automatically make the changes for you. File : v2/public/js/mappingText.js Some of the names in the excel sheets had complex names so those could not have been used as Directory names. So we created a function which on front end could map those name to the correct semantics. There is a function called mappingName in this file which takes a name and transforms it to original text. If you come accross such names use this function for that. File : v2/public/js/index.js This file is responsible for populating data on the Narratives of the painting. But at the same time this file collects some data used in multiple places in the system. Jquery Function The programming model used in the this file is Async waterfall model which gives as Asynchronous flow a synchronous touch (Trust me you need this one here). First thing the function does is it initialize the leaflet maps in narrativeMaps variable. It calls another function initializeNarrativeMaps which does that. It does that using leaflet.js . The reason this is done first is because leaflet.js with openstreet maps sometimes acts really funny and does not load the complete content. So please keep this order. Next, it collects information about all the paintings from /herberger/getPaintings.php REST and populates them in ('narrativePaintingPicker', 'paintingsPaintingPicker', 'comparisonPaintingPicker', 'networkPaintingPicker') which are ids of HTML select boxes. If you want to populate this data in more select boxes, just add that to the array in allPaintingsSelectBox function. It calls setReplicasForNarratives which in itself has another waterfall model. In that waterfall two things are happening. The data(names) about replicas of a painting is collected using the REST /herberger/getReplicaInfo.php . This will be populated in Next thing it populates the replica information by calling updateReplicaInfo . Where that function call does following jobs. Clear the previous leaflet markers if any. At cold start they would be empty $(\"#narrativesImage\").attr(\"src\", data['data']['image']); for (var iter = 0; iter < narrativeMarkers.length; iter++) { narrativeMaps.removeLayer(narrativeMarkers[iter]); } narrativeMaps.removeLayer(narrativePolyLine); narrativeMaps.removeLayer(narrativeDecorator); narrativeMarkers = []; narrativeLatLngs = []; Update ownerInfo variable which keeps all the data for the current request. This is required as it stores the information for following navigations. Populate the information of the painting ``` var year = data['data']['csvData'][data['data']['csvData'].length - 1]['YEAR']; $('#narrativeYear').html('Year: ' + year); var medium = data['data']['csvData'][data['data']['csvData'].length - 1]['MEDIUM']; $('#narrativeMedium').html('Medium: ' + medium); var size = data['data']['csvData'][data['data']['csvData'].length - 1][' SIZE Height (in)']; $('#narrativeHeight').html('Height(in): ' + size); var location = data['data']['csvData'][data['data']['csvData'].length - 1]['owner_LOC']; $('#narrativePlace').html('Place: ' + location); ``` After that, the information collected in ownerInfor is used to collect all the latitude and longitude to populate the markers on the maps. Those latitudes and longitudes are also used to create a polyline which presents the trajectory. Finally it calls the moveOwnerCounter which uses two variable ownerInfo and ownerCounter (at starting initialized to 0) and populates information on Here a circular queue is used to move over different owners where ownerCounter keeps a check on which owner we are currently looking at. If you see this code. \"$('#visuals_call').on('click', function () { setTimeout(function () { narrativeMaps.invalidateSize() narrativeMaps.fitBounds(group.getBounds()) }, 500) });\" This is just to refresh the maps when the user clicks on visuals from the top menu. It makes sure that leaflet loads the maps properly. getThisOut() and toggleInstruction() These functions are simply showing the instructions in the modal when you click on You should update them if you add more visualisations. Make sure when you add that button in html file you put a on click listener calling getThisOut() . File : v2/public/js/datatablesSetup.js This javascript file is responsible for Collection Browser tab. It uses multiselect and datatables to do that. They are pretty standard libraries and most of the configuration that we use is by default configuration of those to libraries. The first thing this script does is that it collects the information from /herberger/getRawData.php . Next thing it does is that it initializes the .multi-select class. To know which classes belong to this CSS class, go to v2/index.html and look for multi-select class objects. All of them are wrapped into a div . It should be easy to find. The configuration is by default same as multiselect but in afterSelect and afterDeselect just one function call is added updateSearchCriteria which will be explained later. After that all the data is inserted in the datatable in the following code snippet. for (iter in data) { $('#rawDataSrc').append('<tr><td>' + data[iter]['paintingName'] + '</td><td><img src=\"' + data[iter]['paintingImage'] + '\" alt=\"No-Image\" class=\"img-thumbnail img-fluid\" style=\"max-height:300px; max-width:200px;\"/></td><td>' + data[iter]['replicaId'] + '</td>' + '<td>' + data[iter]['ownerNumber'] + '</td>' + '<td>' + data[iter]['ownerName'] + '</td>' + '<td>' + data[iter]['ownerCity'] + '</td>' + '<td><img src=\"' + data[iter]['ownerImage'] + '\" alt=\"No-Image\" class=\"img-thumbnail img-fluid\" style=\"max-height:300px; max-width:200px;\"/></td><td>' + data[iter]['ownerProfession'] + '</td></tr>') } To update data on Advance Filters we will use Datatables search mechanism. First we update the search criteria in updateSearchCriteria function. First it starts with initializing variables var array = { '#paitingFilter': true, '#replicaFilter': true, '#owernFilter': true, '#professionFilter': true, '#ownerCityFilter': true, '#ownerNumberFilter': true }; This is just saying we need to update the following ids . Then we look at multiselect ids if they are set or have some values then the respective multiselect does not need to be udpated. Plus those who need to be updated we change there values in the following code. for (iter in data) { if (($('#paitingFilter').val().length == 0 || $('#paitingFilter').val().indexOf(data[iter]['paintingName']) != -1) && ($('#replicaFilter').val().length == 0 || $('#replicaFilter').val().indexOf(data[iter]['replicaId']) != -1) && ($('#professionFilter').val().length == 0 || $('#professionFilter').val().indexOf(data[iter]['ownerProfession']) != -1) && ($('#owernFilter').val().length == 0 || $('#owernFilter').val().indexOf(data[iter]['ownerName']) != -1) && ($('#ownerCityFilter').val().length == 0 || $('#ownerCityFilter').val().indexOf(data[iter]['ownerCity']) != -1) && ($('#ownerNumberFilter').val().length == 0 || $('#ownerNumberFilter').val().indexOf(data[iter]['ownerNumber']) != -1)) { ownerNames[data[iter]['ownerName'].trim()] = true; paintingNames[data[iter]['paintingName'].trim()] = true; replicaIds[data[iter]['replicaId'].trim()] = true; professions[data[iter]['ownerProfession'].trim()] = true; ownerCity[data[iter]['ownerCity'].trim()] = true; ownerNumber[data[iter]['ownerNumber'].trim()] = true; } } That will collect new data if something has been selected and changes are required in advance filter column. PS the data is not update yet in datatables yet. When the user will click on the Apply button, the information that has been just update in advance filter column that will we used in Search features of the datatables. I have used $.fn.dataTable.ext.search.push call in searchRawData which is a Datatables api. That will update the raw data content. Some of the datatables configuration that have been changed are as follows. { paging: true, columnDefs: [ { width: 200, targets: [0, 1, 2, 3, 4, 5] } ], \"searching\": true, fixedColumns: true } File : v2/public/js/transactionNetwork.js This file populates the data on the transactional network tab. It has one function which encapsulates all the work for this visualisation. That function is called from v2/public/js/index.js as some of the data required by this visualisation can be reused from the data collected in narratives. The function is startNetorkSimulation . The idea of this visualisation is taken from followind D3 visuals. * https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a (A simple D3 force directed graph) * http://bl.ocks.org/eyaler/10586116 (Highlighting of the nodes) * https://bl.ocks.org/denisemauldin/cdd667cbaf7b45d600a634c8ae32fae5 (The filtering of nodes). It starts with setReplicasForNetwork function inside startNetorkSimulation where it collects the data. Now if a painting is selected then getSocialNetworkData.php will be called else allSocialNetwork.php will be called. Also there is a Jquery timeslider which tells from which year to which year the data is required. The data that is returned from the REST end is configurable straight into the d3 code. Once that data is collected update_node_data_filter is called which propogates the create , update , delete flow of the d3.js. Most of the idea is taken from the links above, but, one feature that we added which is different from that is the tooltips. For that what we do is we collect all the network information of the node when you hover on the node in the following code. link.style('stroke-width', function (l) { if (mapping.indexOf(l['replicaId']) != -1) { if (l.source !== d) { if (array.indexOf(l.source) === -1) { l.source.s = new Set(); l.source.s.add(l['replicaId']); array.push(l.source); } else { var index = array.indexOf(l.source); array[index].s.add(l['replicaId']); } } if (l.target !== d) { if (array.indexOf(l.target) === -1) { l.target.s = new Set(); l.target.s.add(l['replicaId']); array.push(l.target); } else { var index = array.indexOf(l.target); array[index].s.add(l['replicaId']); } } return 4; } else { return 1; } }); The array in the above code is collecting all the nodes which should have higher opacity as well as changes the stroke width to 4 of the links which are a part of the network of that node on which you hovered on. In that same mouseover call a loop over all the nodes is started and all the nodes of the array are given a higher opacity value and others are made translucent. While that is a done a rectangle and text is also appended to the nodes which have higher opacity which acts as a tooltip. Once you move the mouse out of the node the node, all the changes are reverted back. Nothing fancy just plain old javascript functionality doing the trick. Some function toggle_museum , toggle_auction , and toggle_individual as the name implies are used to toggle the display of the types of the nodes in the graph. File : v2/index.html I wanted to mention some points regarding the content in the html file. There is some textual content (Bibliography, Methods and Instructions etc) which was provided by Professor Julie Codell. For that I used free online (tool)[https://document.online-convert.com/convert-to-html] which can convert a docx to html. PS: only the textual content is converted and not the literature of the research. Make sure you do the same. The template used is Bootstrap 4 template. Most of the styling done is pretty basic and easy to understand bootstrap syntax.","title":"Front End"},{"location":"Frontend/#version-2-front-end","text":"In this knowledge of HTML, CSS3 and Javascript knowledge is assumed. The template we used for the version can be found here . Most of the styling stuff is used from Bootstrap 4. If you are interested in styling changes visit v2/index.html and change accordingly with bootstrap.","title":"Version 2 - Front End"},{"location":"Frontend/#file-v2publiccssindexcss","text":"This file contains CSS 3 code for some of the utilities we used in developing visualisation. In the code we mentioned in the comments that for what widget/visualisation the styling is done. You can reference that. Here it is assumed that the developer knows CSS.","title":"File : v2/public/css/index.css"},{"location":"Frontend/#file-v2publicjschord_diagramjs","text":"This file is imported in index.html and the code in this file is responsible for populating the data for chord visuals. Algorithm: It makes a hit on REST API: /herberger/chordDiagram.php to collect the data using Jquery get request. The data is expected in following format { \"type\" : \"Success\", \"message\" : \"Data found\", \"data\": { \"matrix\": { \"<year>\":{ \"<Seller Name>\" : { \"<Buyer Name>\": <How Many Paintings> } } } } } The data returned has a dictionary with keys as year numbers. We run a loop on the dictionary key to build each and every chord diagram. To build the chord diagram for every year range build_chord will run and it takes 3 parameters matrix(adjacency matrix for the graph), names(owners who were involved in the transactions) and id which will be used to fetch the specific svg for this chord. How an individual chord is created is a follows: First the names are sorted on the basis of type of profession they are in. So dealers will have priority 1, museums will have priority 2 and individuals will have priority 3. Then we create a adjaceny matrix array as D3 requires that. Once that is done we have all the ingridients for the creating the d3 chord. If you don't know how to use D3 chord diagram follow this tutorial . To provide with the on hover lighting effect what we have done is we have set the opacity of the ribbons in the D3 chord with opacity 0.7. Once you hover over a ribbon the opacity is set to 1 which makes the ribbon prominent. Once you hover out the opacity is again set to 0.7. It has built with traditional d3 visualisation so please follow the tutorial mentioned if you don't understand how to make d3 chord charts.","title":"File : v2/public/js/chord_diagram.js"},{"location":"Frontend/#file-v2publicjscomparisontabjs","text":"This file is also imported by index.html and the code in the file populates the Trajectory Comparison maps. The data is expected in the following format. { \"type\" : \"Success\", \"message\" : \"Data found\", \"data\": { \"<Replica Id>\": JSONArray([(Latitude), (Longitude), (Year), (Painting Type), (Size), (City)......]) } } Algorithm: Whenever a user clicks on the left panel option Trajectory Comparison after 1 second the update is called. Why there is a delay because Leaflet, the library used for map visuals won't work properly if the maps are not visible and it takes time for browser to render things. So to compensate for that we put a delay. Now how maps are populated is first /herberger/getComparisonNetwork.php?name=<painting name> is called using ajax get of jquery. Painting name is automatically picked from the dropdown and the content in the dropdown is populated in v2/public/js/index/js . The data collected is in form of key value pair where key is the replica id for the painting value is information array of different geographical information. This is sufficient to populate the data for Leaflet. So based on number of replicas tiles are created and are populated with maps and trajectories. PS: onchange listener is active on the dropdown. This code will be available in this file. So if you change the dropdown the content updates. The id for the dropdown is #comparisonPaintingPicker .","title":"File : v2/public/js/comparisonTab.js"},{"location":"Frontend/#file-v2publicjshistogramsjs","text":"This file is also imported by index.html and the code in the fie populates the content for Histogram Visuals. Algorithm: A little knowledge on Highcharts.js is assumed here. If you don't know, you don't need to learn entire thing. Just read the options of this visualisation. In the visualisation mentioned we have changed just the data and remaining things are same so it should be pretty starightford to build something in this domain. If you add more excel sheets or plan to add more artists, you will need to update the content in the options of the Highcharts.js. It should automatically make the changes for you.","title":"File : v2/public/js/histograms.js"},{"location":"Frontend/#file-v2publicjsmappingtextjs","text":"Some of the names in the excel sheets had complex names so those could not have been used as Directory names. So we created a function which on front end could map those name to the correct semantics. There is a function called mappingName in this file which takes a name and transforms it to original text. If you come accross such names use this function for that.","title":"File : v2/public/js/mappingText.js"},{"location":"Frontend/#file-v2publicjsindexjs","text":"This file is responsible for populating data on the Narratives of the painting. But at the same time this file collects some data used in multiple places in the system. Jquery Function The programming model used in the this file is Async waterfall model which gives as Asynchronous flow a synchronous touch (Trust me you need this one here). First thing the function does is it initialize the leaflet maps in narrativeMaps variable. It calls another function initializeNarrativeMaps which does that. It does that using leaflet.js . The reason this is done first is because leaflet.js with openstreet maps sometimes acts really funny and does not load the complete content. So please keep this order. Next, it collects information about all the paintings from /herberger/getPaintings.php REST and populates them in ('narrativePaintingPicker', 'paintingsPaintingPicker', 'comparisonPaintingPicker', 'networkPaintingPicker') which are ids of HTML select boxes. If you want to populate this data in more select boxes, just add that to the array in allPaintingsSelectBox function. It calls setReplicasForNarratives which in itself has another waterfall model. In that waterfall two things are happening. The data(names) about replicas of a painting is collected using the REST /herberger/getReplicaInfo.php . This will be populated in Next thing it populates the replica information by calling updateReplicaInfo . Where that function call does following jobs. Clear the previous leaflet markers if any. At cold start they would be empty $(\"#narrativesImage\").attr(\"src\", data['data']['image']); for (var iter = 0; iter < narrativeMarkers.length; iter++) { narrativeMaps.removeLayer(narrativeMarkers[iter]); } narrativeMaps.removeLayer(narrativePolyLine); narrativeMaps.removeLayer(narrativeDecorator); narrativeMarkers = []; narrativeLatLngs = []; Update ownerInfo variable which keeps all the data for the current request. This is required as it stores the information for following navigations. Populate the information of the painting ``` var year = data['data']['csvData'][data['data']['csvData'].length - 1]['YEAR']; $('#narrativeYear').html('Year: ' + year); var medium = data['data']['csvData'][data['data']['csvData'].length - 1]['MEDIUM']; $('#narrativeMedium').html('Medium: ' + medium); var size = data['data']['csvData'][data['data']['csvData'].length - 1][' SIZE Height (in)']; $('#narrativeHeight').html('Height(in): ' + size); var location = data['data']['csvData'][data['data']['csvData'].length - 1]['owner_LOC']; $('#narrativePlace').html('Place: ' + location); ``` After that, the information collected in ownerInfor is used to collect all the latitude and longitude to populate the markers on the maps. Those latitudes and longitudes are also used to create a polyline which presents the trajectory. Finally it calls the moveOwnerCounter which uses two variable ownerInfo and ownerCounter (at starting initialized to 0) and populates information on Here a circular queue is used to move over different owners where ownerCounter keeps a check on which owner we are currently looking at. If you see this code. \"$('#visuals_call').on('click', function () { setTimeout(function () { narrativeMaps.invalidateSize() narrativeMaps.fitBounds(group.getBounds()) }, 500) });\" This is just to refresh the maps when the user clicks on visuals from the top menu. It makes sure that leaflet loads the maps properly. getThisOut() and toggleInstruction() These functions are simply showing the instructions in the modal when you click on You should update them if you add more visualisations. Make sure when you add that button in html file you put a on click listener calling getThisOut() .","title":"File : v2/public/js/index.js"},{"location":"Frontend/#file-v2publicjsdatatablessetupjs","text":"This javascript file is responsible for Collection Browser tab. It uses multiselect and datatables to do that. They are pretty standard libraries and most of the configuration that we use is by default configuration of those to libraries. The first thing this script does is that it collects the information from /herberger/getRawData.php . Next thing it does is that it initializes the .multi-select class. To know which classes belong to this CSS class, go to v2/index.html and look for multi-select class objects. All of them are wrapped into a div . It should be easy to find. The configuration is by default same as multiselect but in afterSelect and afterDeselect just one function call is added updateSearchCriteria which will be explained later. After that all the data is inserted in the datatable in the following code snippet. for (iter in data) { $('#rawDataSrc').append('<tr><td>' + data[iter]['paintingName'] + '</td><td><img src=\"' + data[iter]['paintingImage'] + '\" alt=\"No-Image\" class=\"img-thumbnail img-fluid\" style=\"max-height:300px; max-width:200px;\"/></td><td>' + data[iter]['replicaId'] + '</td>' + '<td>' + data[iter]['ownerNumber'] + '</td>' + '<td>' + data[iter]['ownerName'] + '</td>' + '<td>' + data[iter]['ownerCity'] + '</td>' + '<td><img src=\"' + data[iter]['ownerImage'] + '\" alt=\"No-Image\" class=\"img-thumbnail img-fluid\" style=\"max-height:300px; max-width:200px;\"/></td><td>' + data[iter]['ownerProfession'] + '</td></tr>') } To update data on Advance Filters we will use Datatables search mechanism. First we update the search criteria in updateSearchCriteria function. First it starts with initializing variables var array = { '#paitingFilter': true, '#replicaFilter': true, '#owernFilter': true, '#professionFilter': true, '#ownerCityFilter': true, '#ownerNumberFilter': true }; This is just saying we need to update the following ids . Then we look at multiselect ids if they are set or have some values then the respective multiselect does not need to be udpated. Plus those who need to be updated we change there values in the following code. for (iter in data) { if (($('#paitingFilter').val().length == 0 || $('#paitingFilter').val().indexOf(data[iter]['paintingName']) != -1) && ($('#replicaFilter').val().length == 0 || $('#replicaFilter').val().indexOf(data[iter]['replicaId']) != -1) && ($('#professionFilter').val().length == 0 || $('#professionFilter').val().indexOf(data[iter]['ownerProfession']) != -1) && ($('#owernFilter').val().length == 0 || $('#owernFilter').val().indexOf(data[iter]['ownerName']) != -1) && ($('#ownerCityFilter').val().length == 0 || $('#ownerCityFilter').val().indexOf(data[iter]['ownerCity']) != -1) && ($('#ownerNumberFilter').val().length == 0 || $('#ownerNumberFilter').val().indexOf(data[iter]['ownerNumber']) != -1)) { ownerNames[data[iter]['ownerName'].trim()] = true; paintingNames[data[iter]['paintingName'].trim()] = true; replicaIds[data[iter]['replicaId'].trim()] = true; professions[data[iter]['ownerProfession'].trim()] = true; ownerCity[data[iter]['ownerCity'].trim()] = true; ownerNumber[data[iter]['ownerNumber'].trim()] = true; } } That will collect new data if something has been selected and changes are required in advance filter column. PS the data is not update yet in datatables yet. When the user will click on the Apply button, the information that has been just update in advance filter column that will we used in Search features of the datatables. I have used $.fn.dataTable.ext.search.push call in searchRawData which is a Datatables api. That will update the raw data content. Some of the datatables configuration that have been changed are as follows. { paging: true, columnDefs: [ { width: 200, targets: [0, 1, 2, 3, 4, 5] } ], \"searching\": true, fixedColumns: true }","title":"File : v2/public/js/datatablesSetup.js"},{"location":"Frontend/#file-v2publicjstransactionnetworkjs","text":"This file populates the data on the transactional network tab. It has one function which encapsulates all the work for this visualisation. That function is called from v2/public/js/index.js as some of the data required by this visualisation can be reused from the data collected in narratives. The function is startNetorkSimulation . The idea of this visualisation is taken from followind D3 visuals. * https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a (A simple D3 force directed graph) * http://bl.ocks.org/eyaler/10586116 (Highlighting of the nodes) * https://bl.ocks.org/denisemauldin/cdd667cbaf7b45d600a634c8ae32fae5 (The filtering of nodes). It starts with setReplicasForNetwork function inside startNetorkSimulation where it collects the data. Now if a painting is selected then getSocialNetworkData.php will be called else allSocialNetwork.php will be called. Also there is a Jquery timeslider which tells from which year to which year the data is required. The data that is returned from the REST end is configurable straight into the d3 code. Once that data is collected update_node_data_filter is called which propogates the create , update , delete flow of the d3.js. Most of the idea is taken from the links above, but, one feature that we added which is different from that is the tooltips. For that what we do is we collect all the network information of the node when you hover on the node in the following code. link.style('stroke-width', function (l) { if (mapping.indexOf(l['replicaId']) != -1) { if (l.source !== d) { if (array.indexOf(l.source) === -1) { l.source.s = new Set(); l.source.s.add(l['replicaId']); array.push(l.source); } else { var index = array.indexOf(l.source); array[index].s.add(l['replicaId']); } } if (l.target !== d) { if (array.indexOf(l.target) === -1) { l.target.s = new Set(); l.target.s.add(l['replicaId']); array.push(l.target); } else { var index = array.indexOf(l.target); array[index].s.add(l['replicaId']); } } return 4; } else { return 1; } }); The array in the above code is collecting all the nodes which should have higher opacity as well as changes the stroke width to 4 of the links which are a part of the network of that node on which you hovered on. In that same mouseover call a loop over all the nodes is started and all the nodes of the array are given a higher opacity value and others are made translucent. While that is a done a rectangle and text is also appended to the nodes which have higher opacity which acts as a tooltip. Once you move the mouse out of the node the node, all the changes are reverted back. Nothing fancy just plain old javascript functionality doing the trick. Some function toggle_museum , toggle_auction , and toggle_individual as the name implies are used to toggle the display of the types of the nodes in the graph.","title":"File : v2/public/js/transactionNetwork.js"},{"location":"Frontend/#file-v2indexhtml","text":"I wanted to mention some points regarding the content in the html file. There is some textual content (Bibliography, Methods and Instructions etc) which was provided by Professor Julie Codell. For that I used free online (tool)[https://document.online-convert.com/convert-to-html] which can convert a docx to html. PS: only the textual content is converted and not the literature of the research. Make sure you do the same. The template used is Bootstrap 4 template. Most of the styling done is pretty basic and easy to understand bootstrap syntax.","title":"File : v2/index.html"}]}